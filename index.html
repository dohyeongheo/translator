<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI ë‰˜ì•™ìŠ¤ í†µì—­ê¸° V11 (Simple)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&family=Sarabun:wght@400;700&display=swap"
        rel="stylesheet">
    <!-- Tesseract.js for OCR -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>

    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #121212;
            color: white;
            -webkit-tap-highlight-color: transparent;
        }

        .thai-font {
            font-family: 'Sarabun', sans-serif;
        }

        .toss-dark {
            background-color: #1e1e1e;
            color: #f2f4f6;
        }

        .toss-input {
            background-color: #2c2c2c;
            border: none;
            color: white;
            transition: all 0.2s;
        }

        .toss-input:focus {
            background-color: #333;
            outline: 2px solid #3b82f6;
            outline-offset: 2px;
        }

        .toss-button {
            background-color: #3182f6;
            transition: all 0.2s;
        }

        .toss-button:active {
            transform: scale(0.96);
            opacity: 0.9;
        }

        /* ì–¸ì–´ ì„ íƒ ë²„íŠ¼ */
        .lang-btn {
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 700;
            background-color: #2c2c2c;
            color: #a1a1aa;
            transition: all 0.2s;
        }

        .lang-btn.active {
            background-color: #3b82f6;
            color: white;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        /* UI ì–¸ì–´ ìŠ¤ìœ„ì²˜ */
        .ui-lang-btn {
            opacity: 0.5;
            filter: grayscale(1);
            transition: all 0.2s;
        }

        .ui-lang-btn.active {
            opacity: 1;
            filter: grayscale(0);
            transform: scale(1.1);
        }

        /* í„ìŠ¤ ì• ë‹ˆë©”ì´ì…˜ */
        .pulse-text {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }

        /* Toast Animation */
        @keyframes slide-up {
            from {
                opacity: 0;
                transform: translate(-50%, 20px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }

        .animate-slide-up {
            animation: slide-up 0.3s ease-out;
        }

        /* ì„¤ì • ëª¨ë‹¬ */
        .modal-overlay {
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(4px);
        }

        /* ëª¨ë°”ì¼ ìŠ¤íƒ€ì¼ (ê¸°ë³¸) */
        .mobile-only {
            display: block;
        }

        .desktop-only {
            display: none;
        }

        /* PC ìŠ¤íƒ€ì¼ - ë¯¸ë””ì–´ ì¿¼ë¦¬ë¡œ ì§ì ‘ ì ìš© */
        @media (min-width: 768px) {
            .container-wrapper {
                max-width: 1400px !important;
                margin: 0 auto;
                padding: 0 2rem;
            }

            .mobile-only {
                display: none;
            }

            .desktop-only {
                display: block;
            }

            header {
                padding: 2rem 2.5rem !important;
                border-radius: 0 0 1.5rem 1.5rem;
            }

            .lang-btn {
                padding: 10px 18px !important;
                font-size: 14px !important;
                border-radius: 10px;
            }

            #input-text {
                min-height: 200px !important;
                font-size: 18px !important;
                padding: 1.5rem !important;
            }

            #output-text {
                font-size: 2rem !important;
                line-height: 1.6;
            }

            .toss-button {
                width: 64px !important;
                height: 64px !important;
                font-size: 1.25rem !important;
            }

            .toss-button:hover {
                background-color: #2563eb;
                transform: scale(1.05);
            }

            .lang-btn:hover {
                background-color: #3b82f6;
                color: white;
            }

            main {
                padding: 2rem !important;
                max-width: 100%;
            }

            .toss-dark {
                padding: 2rem !important;
            }

            h1 {
                font-size: 1.75rem !important;
            }

            #result-card .toss-dark {
                padding: 2.5rem !important;
            }

            #nuance-group {
                grid-template-columns: repeat(4, 1fr) !important;
                gap: 1rem !important;
            }

            /* ëª¨ë°”ì¼ì—ì„œë§Œ 2ì—´ ìœ ì§€ */
            @media (max-width: 767px) {
                #nuance-group {
                    grid-template-columns: repeat(2, 1fr) !important;
                }
            }

            #nuance-group button {
                padding: 1.25rem !important;
                font-size: 14px !important;
            }

            #word-guide-section {
                font-size: 14px;
            }

            #word-guide-content {
                font-size: 13px;
            }
        }

        /* ëŒ€í˜• í™”ë©´ ìŠ¤íƒ€ì¼ (1920px ì´ìƒ) */
        @media (min-width: 1920px) {
            .container-wrapper {
                max-width: 1600px !important;
                padding: 0 3rem !important;
            }

            header {
                padding: 2.5rem 3rem !important;
            }

            main {
                padding: 3rem !important;
            }

            #input-text {
                min-height: 250px !important;
                font-size: 20px !important;
                padding: 2rem !important;
            }

            #output-text {
                font-size: 2.25rem !important;
            }

            .lang-btn {
                padding: 12px 22px !important;
                font-size: 15px !important;
            }

            .toss-button {
                width: 72px !important;
                height: 72px !important;
                font-size: 1.5rem !important;
            }

            h1 {
                font-size: 2rem !important;
            }

            .toss-dark {
                padding: 2.5rem !important;
            }

            #nuance-group {
                gap: 1.5rem !important;
            }

            #nuance-group button {
                padding: 1.5rem !important;
                font-size: 15px !important;
            }
        }

        /* ëª¨ë°”ì¼ ìŠ¤íƒ€ì¼ */
        @media (max-width: 767px) {
            body.is-mobile .container-wrapper {
                max-width: 100%;
            }

            body.is-mobile header {
                padding: 1rem;
            }

            body.is-mobile .lang-btn {
                padding: 6px 10px;
                font-size: 11px;
            }

            body.is-mobile #input-text {
                min-height: 120px;
                font-size: 16px;
            }

            body.is-mobile #output-text {
                font-size: 1.5rem;
            }

            body.is-mobile .toss-button {
                width: 48px;
                height: 48px;
            }
        }

        /* í„°ì¹˜ ë””ë°”ì´ìŠ¤ ìŠ¤íƒ€ì¼ */
        @media (hover: none) and (pointer: coarse) {
            .toss-button:active {
                transform: scale(0.95);
            }

            .lang-btn:active {
                transform: scale(0.98);
            }
        }
    </style>
</head>

<body class="h-screen flex flex-col overflow-hidden bg-black">
    <div class="container-wrapper h-full flex flex-col">

        <!-- 1. Header & Global UI Switcher -->
        <header class="toss-dark p-4 pb-2 shrink-0 rounded-b-2xl shadow-lg z-10">
            <div class="flex justify-between items-center mb-4">
                <h1 class="text-xl font-black text-blue-400 flex items-center gap-2">
                    Nuance V11 <span class="text-[10px] bg-yellow-600 text-white px-2 py-0.5 rounded-full">LITE</span>
                </h1>
                <div class="flex gap-2">
                    <!-- Settings Button -->
                    <button onclick="toggleSettings()"
                        class="bg-black/30 p-2 rounded-full text-gray-400 hover:text-white transition">
                        <i class="fas fa-cog"></i>
                    </button>
                    <!-- UI Language Switcher -->
                    <div class="flex gap-2 bg-black/30 p-1.5 rounded-full">
                        <button onclick="setUILang('ko')" class="ui-lang-btn active text-lg">ğŸ‡°ğŸ‡·</button>
                        <button onclick="setUILang('th')" class="ui-lang-btn text-lg">ğŸ‡¹ğŸ‡­</button>
                        <button onclick="setUILang('en')" class="ui-lang-btn text-lg">ğŸ‡ºğŸ‡¸</button>
                    </div>
                </div>
            </div>

            <!-- Trans Language Selector -->
            <div class="flex items-center justify-between bg-black/30 p-1.5 rounded-xl mb-2">
                <div class="flex gap-1" id="source-lang-group">
                    <button data-lang="auto" class="lang-btn active" data-i18n="auto">ìë™</button>
                    <button data-lang="ko" class="lang-btn" data-i18n="ko">í•œêµ­ì–´</button>
                    <button data-lang="th" class="lang-btn" data-i18n="th">íƒœêµ­ì–´</button>
                    <button data-lang="en" class="lang-btn" data-i18n="en">ì˜ì–´</button>
                </div>
                <i class="fas fa-arrow-right text-gray-600 text-xs mx-1"></i>
                <div class="flex gap-1" id="target-lang-group">
                    <button data-lang="th" class="lang-btn active" data-i18n="th">íƒœêµ­ì–´</button>
                    <button data-lang="ko" class="lang-btn" data-i18n="ko">í•œêµ­ì–´</button>
                    <button data-lang="en" class="lang-btn" data-i18n="en">ì˜ì–´</button>
                </div>
            </div>
        </header>

        <!-- 2. Main Content -->
        <main class="flex-1 overflow-y-auto p-4 space-y-4 pb-32">

            <!-- Persona Settings (Simplified) -->
            <div class="toss-dark p-4 rounded-2xl border border-gray-800 space-y-3">
                <!-- Nuance (ë‰˜ì•™ìŠ¤) -->
                <div>
                    <h2
                        class="text-[10px] font-bold text-gray-500 mb-2 uppercase tracking-wider flex items-center gap-1">
                        <i class="fas fa-sliders text-purple-400"></i> <span data-i18n="nuance">ë‰˜ì•™ìŠ¤ (Tone)</span>
                    </h2>
                    <div class="grid gap-2" id="nuance-group" style="grid-template-columns: repeat(2, 1fr);">
                        <button data-tone="polite"
                            class="p-3 bg-[#2c2c2c] rounded-xl text-xs font-bold text-gray-400 hover:text-white active border-2 border-transparent transition-all">
                            ğŸ™ <span data-i18n="polite">ì˜ˆì˜ ë°”ë¥´ê²Œ</span>
                        </button>
                        <button data-tone="normal"
                            class="p-3 bg-[#2c2c2c] rounded-xl text-xs font-bold text-gray-400 hover:text-white border-2 border-transparent transition-all">
                            ğŸ˜ <span data-i18n="normal">ë³´í†µ</span>
                        </button>
                        <button data-tone="casual"
                            class="p-3 bg-[#2c2c2c] rounded-xl text-xs font-bold text-gray-400 hover:text-white border-2 border-transparent transition-all">
                            â˜• <span data-i18n="casual">í¸ì•ˆí•˜ê²Œ</span>
                        </button>
                        <button data-tone="playful"
                            class="p-3 bg-[#2c2c2c] rounded-xl text-xs font-bold text-gray-400 hover:text-white border-2 border-transparent transition-all">
                            ğŸ˜œ <span data-i18n="playful">ì¥ë‚œìŠ¤ëŸ½ê²Œ</span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Input Area -->
            <div class="space-y-2">
                <!-- ë²„íŠ¼ ê·¸ë£¹ (ì…ë ¥ì°½ ìœ„ì— ë³„ë„ ì˜ì—­) -->
                <div class="flex gap-2">
                    <!-- ìŒì„± ì…ë ¥ ë²„íŠ¼ -->
                    <button onclick="startVoiceInput()" id="voice-input-btn"
                        class="bg-gray-800 hover:bg-gray-700 text-gray-400 hover:text-blue-400 px-4 py-2 rounded-lg transition-colors flex items-center gap-2"
                        title="ìŒì„± ì…ë ¥">
                        <i class="fas fa-microphone"></i>
                        <span class="text-xs">ìŒì„± ì…ë ¥</span>
                    </button>

                    <!-- ì´ë¯¸ì§€ ì—…ë¡œë“œ ë²„íŠ¼ -->
                    <button onclick="document.getElementById('image-input').click()"
                        class="bg-gray-800 hover:bg-gray-700 text-gray-400 hover:text-green-400 px-4 py-2 rounded-lg transition-colors flex items-center gap-2"
                        title="ì´ë¯¸ì§€ì—ì„œ í…ìŠ¤íŠ¸ ì¶”ì¶œ">
                        <i class="fas fa-image"></i>
                        <span class="text-xs">ì´ë¯¸ì§€</span>
                    </button>
                </div>
                <input type="file" id="image-input" accept="image/*" class="hidden" onchange="handleImageUpload(event)">

                <!-- ì…ë ¥ì°½ -->
                <div class="relative">
                    <textarea id="input-text"
                        class="w-full h-32 p-5 rounded-2xl toss-input text-lg leading-relaxed resize-none shadow-inner"
                        placeholder="ì—¬ê¸°ì— ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”..."></textarea>

                    <!-- ìŒì„± ì…ë ¥ ìƒíƒœ í‘œì‹œ -->
                    <div id="voice-status"
                        class="hidden absolute top-2 right-2 text-xs text-blue-400 flex items-center gap-1 bg-gray-800/90 px-3 py-1.5 rounded-lg backdrop-blur-sm border border-blue-500/30">
                        <i class="fas fa-circle animate-pulse"></i> <span>ë“£ëŠ” ì¤‘...</span>
                    </div>

                    <!-- OCR ì§„í–‰ ìƒíƒœ -->
                    <div id="ocr-progress"
                        class="hidden absolute inset-0 bg-black/60 flex items-center justify-center rounded-2xl backdrop-blur-sm z-10">
                        <div class="text-center text-white">
                            <i class="fas fa-spinner fa-spin text-2xl mb-2"></i>
                            <p class="text-sm mb-2">ì´ë¯¸ì§€ì—ì„œ í…ìŠ¤íŠ¸ ì¶”ì¶œ ì¤‘...</p>
                            <div class="w-64 bg-gray-700 rounded-full h-2">
                                <div id="ocr-progress-bar" class="bg-blue-500 h-2 rounded-full transition-all"
                                    style="width: 0%"></div>
                            </div>
                            <p id="ocr-progress-text" class="text-xs text-gray-400 mt-2">0%</p>
                        </div>
                    </div>

                    <button onclick="clearInput()" class="absolute top-3 right-3 text-gray-600 hover:text-gray-400 p-2">
                        <i class="fas fa-times-circle text-xl"></i>
                    </button>
                    <button onclick="executeTranslation()"
                        class="absolute bottom-3 right-3 toss-button text-white w-12 h-12 rounded-full flex items-center justify-center shadow-lg shadow-blue-500/30">
                        <i class="fas fa-paper-plane text-lg"></i>
                    </button>
                </div>
            </div>

            <!-- Result Area -->
            <div id="result-card" class="hidden animate-pulse">
                <div class="toss-dark p-5 rounded-2xl border border-gray-700 shadow-2xl relative overflow-hidden">
                    <div class="flex justify-between items-center mb-3">
                        <span id="detected-lang-label"
                            class="text-[10px] font-bold bg-blue-900/50 text-blue-300 px-2 py-1 rounded">DETECTED</span>
                        <div class="flex gap-3">
                            <button onclick="copyResult()" class="text-gray-500 hover:text-white"><i
                                    class="far fa-copy"></i></button>
                            <button onclick="playTTS(state.lastResult, state.lastLang)"
                                class="text-blue-400 hover:text-blue-300"><i id="tts-icon"
                                    class="fas fa-volume-high text-xl"></i></button>
                        </div>
                    </div>
                    <p id="output-text" class="text-2xl font-bold text-white leading-relaxed thai-font break-words"></p>

                    <!-- Word Guide Section -->
                    <div id="word-guide-section" class="hidden mt-4 pt-4 border-t border-gray-700">
                        <button onclick="toggleWordGuide()"
                            class="flex items-center gap-2 text-sm text-blue-400 hover:text-blue-300 transition mb-3">
                            <i class="fas fa-book text-xs"></i>
                            <span id="word-guide-toggle-text" data-i18n="wordGuide">ë‹¨ì–´/í‘œí˜„ ì•ˆë‚´</span>
                            <i id="word-guide-icon" class="fas fa-chevron-down text-xs transition-transform"></i>
                        </button>
                        <div id="word-guide-content" class="hidden space-y-2">
                            <!-- Word guide items will be inserted here -->
                        </div>
                    </div>

                    <!-- Error Log -->
                    <div id="error-log"
                        class="hidden mt-4 p-3 bg-red-900/30 border border-red-800 rounded-lg text-xs text-red-300 font-mono break-all">
                    </div>

                    <!-- Loading -->
                    <div id="loading-spinner"
                        class="hidden absolute inset-0 bg-black/60 flex items-center justify-center backdrop-blur-sm">
                        <div class="flex flex-col items-center">
                            <i class="fas fa-circle-notch fa-spin text-3xl text-blue-500 mb-2"></i>
                            <span class="text-xs text-blue-200 font-bold pulse-text" data-i18n="translating">AI ë²ˆì—­
                                ì¤‘...</span>
                        </div>
                    </div>
                </div>
            </div>

        </main>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="hidden fixed bottom-6 left-1/2 transform -translate-x-1/2 z-50">
        <div class="bg-gray-800 text-white px-6 py-3 rounded-lg shadow-2xl border border-gray-700 flex items-center gap-3 animate-slide-up">
            <i class="fas fa-check-circle text-green-400"></i>
            <span id="toast-message" class="text-sm font-medium"></span>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="hidden fixed inset-0 modal-overlay z-50 flex items-center justify-center p-4">
        <div
            class="toss-dark w-full max-w-sm p-6 rounded-2xl shadow-2xl border border-gray-700 animate-in zoom-in-95 duration-200">
            <h2 class="text-lg font-bold mb-4 flex items-center gap-2">
                <i class="fas fa-key text-yellow-500"></i> API Settings
            </h2>
            <div class="mb-4">
                <label class="text-xs text-gray-400 font-bold mb-1 block">Google Gemini API Key</label>
                <input type="password" id="api-key-input"
                    class="w-full p-3 rounded-xl toss-input text-sm border border-gray-700 focus:border-blue-500"
                    placeholder="Paste your API key here...">
                <p class="text-[10px] text-gray-500 mt-2">
                    * 401 ì˜¤ë¥˜ ì‹œ ë³¸ì¸ì˜ í‚¤ë¥¼ ì…ë ¥í•˜ì„¸ìš”.<br>
                    * í‚¤ëŠ” ë¸Œë¼ìš°ì €ì—ë§Œ ì €ì¥ë©ë‹ˆë‹¤.
                </p>
            </div>
            <div class="flex gap-2">
                <button onclick="toggleSettings()"
                    class="flex-1 p-3 rounded-xl bg-gray-700 text-gray-300 font-bold text-xs hover:bg-gray-600">ì·¨ì†Œ</button>
                <button onclick="saveApiKey()"
                    class="flex-1 p-3 rounded-xl bg-blue-600 text-white font-bold text-xs hover:bg-blue-500">ì €ì¥</button>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIG ---
        const CONFIG = {
            API_BASE_URL: 'https://generativelanguage.googleapis.com/v1beta/models',
            MODEL_NAME: 'gemini-2.5-flash-preview-09-2025',
            DESKTOP_BREAKPOINT: 768
        };

        const defaultApiKey = "";

        // --- I18N DATA ---
        const I18N = {
            ko: {
                auto: "ìë™", ko: "í•œêµ­ì–´", th: "íƒœêµ­ì–´", en: "ì˜ì–´",
                nuance: "ë‰˜ì•™ìŠ¤ (Tone)", polite: "ì˜ˆì˜ ë°”ë¥´ê²Œ", normal: "ë³´í†µ", casual: "í¸ì•ˆí•˜ê²Œ", playful: "ì¥ë‚œìŠ¤ëŸ½ê²Œ",
                placeholder: "ì—¬ê¸°ì— ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”...", translating: "AI ë²ˆì—­ ì¤‘...",
                error: "ì˜¤ë¥˜ ë°œìƒ! ì„¤ì •(âš™ï¸)ì—ì„œ API í‚¤ë¥¼ í™•ì¸í•˜ì„¸ìš”.", copied: "ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!",
                wordGuide: "ë‹¨ì–´/í‘œí˜„ ì•ˆë‚´", word: "ë‹¨ì–´", meaning: "ì˜ë¯¸", example: "ì˜ˆë¬¸", pronunciation: "ë°œìŒ",
                voiceInput: "ìŒì„± ì…ë ¥", imageInput: "ì´ë¯¸ì§€ì—ì„œ í…ìŠ¤íŠ¸ ì¶”ì¶œ", listening: "ë“£ëŠ” ì¤‘...", processing: "ì²˜ë¦¬ ì¤‘..."
            },
            th: {
                auto: "à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´", ko: "à¹€à¸à¸²à¸«à¸¥à¸µ", th: "à¹„à¸—à¸¢", en: "à¸­à¸±à¸‡à¸à¸¤à¸©",
                nuance: "à¸™à¹‰à¸³à¹€à¸ªà¸µà¸¢à¸‡ (Tone)", polite: "à¸ªà¸¸à¸ à¸²à¸", normal: "à¸—à¸±à¹ˆà¸§à¹„à¸›", casual: "à¸à¸±à¸™à¹€à¸­à¸‡", playful: "à¸‚à¸µà¹‰à¹€à¸¥à¹ˆà¸™",
                placeholder: "à¸à¸´à¸¡à¸à¹Œà¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸—à¸µà¹ˆà¸™à¸µà¹ˆ...", translating: "à¸à¸³à¸¥à¸±à¸‡à¹à¸›à¸¥...",
                error: "à¹€à¸à¸´à¸”à¸‚à¹‰à¸­à¸œà¸´à¸”à¸à¸¥à¸²à¸”! à¹‚à¸›à¸£à¸”à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š API Key", copied: "à¸„à¸±à¸”à¸¥à¸­à¸à¹à¸¥à¹‰à¸§!",
                wordGuide: "à¸„à¸³à¹à¸™à¸°à¸™à¸³à¸„à¸³à¸¨à¸±à¸à¸—à¹Œ", word: "à¸„à¸³", meaning: "à¸„à¸§à¸²à¸¡à¸«à¸¡à¸²à¸¢", example: "à¸•à¸±à¸§à¸­à¸¢à¹ˆà¸²à¸‡", pronunciation: "à¸à¸²à¸£à¸­à¸­à¸à¹€à¸ªà¸µà¸¢à¸‡",
                voiceInput: "à¸›à¹‰à¸­à¸™à¹€à¸ªà¸µà¸¢à¸‡", imageInput: "à¸”à¸¶à¸‡à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸ˆà¸²à¸à¸£à¸¹à¸›à¸ à¸²à¸", listening: "à¸à¸³à¸¥à¸±à¸‡à¸Ÿà¸±à¸‡...", processing: "à¸à¸³à¸¥à¸±à¸‡à¸›à¸£à¸°à¸¡à¸§à¸¥à¸œà¸¥..."
            },
            en: {
                auto: "Auto", ko: "Korean", th: "Thai", en: "English",
                nuance: "Nuance", polite: "Polite", normal: "Normal", casual: "Casual", playful: "Playful",
                placeholder: "Type here...", translating: "Translating...",
                error: "Error! Check API Key in Settings.", copied: "Copied!",
                wordGuide: "Word Guide", word: "Word", meaning: "Meaning", example: "Example", pronunciation: "Pronunciation",
                voiceInput: "Voice Input", imageInput: "Extract Text from Image", listening: "Listening...", processing: "Processing..."
            }
        };

        // --- STATE ---
        let state = {
            uiLang: 'ko',
            sourceLang: 'auto',
            targetLang: 'th',
            tone: 'polite',
            lastResult: '',
            lastLang: '',
            apiKey: defaultApiKey,
            isMobile: false,
            isDesktop: false
        };

        // --- VOICE RECOGNITION STATE ---
        let recognition = null;
        let isListening = false;

        // --- DEVICE DETECTION ---
        function detectDevice() {
            const width = window.innerWidth;
            const isDesktop = width >= CONFIG.DESKTOP_BREAKPOINT;

            state.isMobile = !isDesktop;
            state.isDesktop = isDesktop;

            // bodyì— í´ë˜ìŠ¤ ì¶”ê°€/ì œê±°
            document.body.classList.toggle('is-mobile', state.isMobile);
            document.body.classList.toggle('is-desktop', state.isDesktop);

            // ì»¨í…Œì´ë„ˆ ë„ˆë¹„ ì¡°ì • (CSS ë¯¸ë””ì–´ ì¿¼ë¦¬ê°€ ì²˜ë¦¬í•˜ë¯€ë¡œ í´ë˜ìŠ¤ë§Œ ì œê±°)
            const container = document.querySelector('.container-wrapper');
            if (container) {
                container.classList.remove('max-w-md', 'max-w-lg', 'max-w-xl', 'max-w-full');
                if (state.isMobile) {
                    container.classList.add('max-w-full');
                } else {
                    container.style.maxWidth = '';
                }
            }
        }

        // --- INIT ---
        document.addEventListener('DOMContentLoaded', () => {
            // ë””ë°”ì´ìŠ¤ ê°ì§€
            detectDevice();

            // í™”ë©´ í¬ê¸° ë³€ê²½ ì‹œ ì¬ê°ì§€
            let resizeTimer;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    detectDevice();
                }, 150);
            });

            const savedKey = localStorage.getItem('gemini_api_key');
            if (savedKey) state.apiKey = savedKey;

            setupRadioButtons('source-lang-group', 'sourceLang', 'dataset.lang');
            setupRadioButtons('target-lang-group', 'targetLang', 'dataset.lang');
            setupRadioButtons('nuance-group', 'tone', 'dataset.tone');

            setActiveBtn('nuance-group', 'polite', 'border-blue-500', 'text-white', 'bg-blue-900/20');

            setUILang('ko');
        });

        // --- SETTINGS LOGIC ---
        function toggleSettings() {
            const modal = document.getElementById('settings-modal');
            const input = document.getElementById('api-key-input');

            if (modal.classList.contains('hidden')) {
                modal.classList.remove('hidden');
                input.value = state.apiKey;
            } else {
                modal.classList.add('hidden');
            }
        }

        function saveApiKey() {
            const input = document.getElementById('api-key-input');
            const newKey = input.value.trim();
            if (newKey) {
                state.apiKey = newKey;
                localStorage.setItem('gemini_api_key', newKey);
                alert("API í‚¤ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.");
                toggleSettings();
            } else {
                alert("API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.");
            }
        }

        function setUILang(lang) {
            state.uiLang = lang;
            document.querySelectorAll('.ui-lang-btn').forEach(btn => btn.classList.remove('active'));
            const btns = document.querySelectorAll('.ui-lang-btn');
            if (btns.length >= 3) {
                if (lang === 'ko' && btns[0]) btns[0].classList.add('active');
                if (lang === 'th' && btns[1]) btns[1].classList.add('active');
                if (lang === 'en' && btns[2]) btns[2].classList.add('active');
            }

            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.dataset.i18n;
                if (I18N[lang] && I18N[lang][key]) el.innerText = I18N[lang][key];
            });
            const inputText = document.getElementById('input-text');
            if (inputText && I18N[lang]) inputText.placeholder = I18N[lang].placeholder;

            // Update word guide toggle text
            const toggleText = document.getElementById('word-guide-toggle-text');
            if (toggleText && I18N[lang] && I18N[lang].wordGuide) {
                toggleText.innerText = I18N[lang].wordGuide;
            }
        }

        function setupRadioButtons(groupId, stateKey, dataPath) {
            const container = document.getElementById(groupId);
            if (!container) {
                console.warn(`Container with id "${groupId}" not found`);
                return;
            }
            container.querySelectorAll('button').forEach(btn => {
                btn.addEventListener('click', () => {
                    container.querySelectorAll('button').forEach(b => {
                        b.classList.remove('active', 'border-blue-500', 'text-white', 'bg-blue-900/20');
                    });
                    btn.classList.add('active', 'border-blue-500', 'text-white', 'bg-blue-900/20');
                    const val = dataPath.includes('tone') ? btn.dataset.tone : btn.dataset.lang;
                    state[stateKey] = val;
                });
            });
        }

        function setActiveBtn(groupId, val, ...classes) {
            const container = document.getElementById(groupId);
            const selector = `[data-tone="${val}"]`;
            const btn = container.querySelector(selector);
            if (btn) btn.classList.add(...classes, 'active');
        }

        function clearInput() {
            document.getElementById('input-text').value = '';
            document.getElementById('result-card').classList.add('hidden');
            const wordGuideSection = document.getElementById('word-guide-section');
            if (wordGuideSection) wordGuideSection.classList.add('hidden');
            document.getElementById('input-text').focus();
        }

        // --- CORE LOGIC ---

        async function executeTranslation() {
            const text = document.getElementById('input-text').value.trim();
            if (!text) return;

            const resultCard = document.getElementById('result-card');
            const outputText = document.getElementById('output-text');
            const spinner = document.getElementById('loading-spinner');
            const errorLog = document.getElementById('error-log');

            resultCard.classList.remove('hidden');
            resultCard.classList.remove('animate-pulse');
            spinner.classList.remove('hidden');
            errorLog.classList.add('hidden');

            try {
                await translateShortText(text, outputText, spinner, errorLog);
            } catch (error) {
                handleTranslationError(error, spinner, outputText, errorLog);
            }
        }

        function handleTranslationError(error, spinner, outputText, errorLog) {
            spinner.classList.add('hidden');
            outputText.innerText = I18N[state.uiLang].error;
            errorLog.innerText = `Error: ${error.message}`;
            errorLog.classList.remove('hidden');
            if (error.message.includes("401")) {
                setTimeout(() => toggleSettings(), 1500);
            }
        }

        function buildPersonaDescription(tone) {
            let personaDesc = "Gender: Male. ";
            if (tone === 'polite') personaDesc += "Tone: Very Polite & Formal. ";
            else if (tone === 'normal') personaDesc += "Tone: Standard/Neutral. ";
            else if (tone === 'casual') personaDesc += "Tone: Casual/Friendly. ";
            else if (tone === 'playful') personaDesc += "Tone: Witty, Playful. ";
            return personaDesc;
        }

        function buildTranslationPrompt(text, sourceLang, targetLang, tone) {
            const personaDesc = buildPersonaDescription(tone);
            return `
                Role: Expert AI Interpreter.
                Input: "${text}"
                Config: Source=${sourceLang}, Target=${targetLang}
                Persona: ${personaDesc}

                Rules:
                1. If Source is 'auto', detect language.
                2. Map languages: ko=Korean, th=Thai, en=English.
                3. If input is Thai/English -> Translate to Korean.
                4. If input is Korean -> Translate to Target (Default Thai).
                5. IMPORTANT: Apply the Persona Tone strictly. For Thai, ALWAYS use 'Krub' (Male ending).
                6. Extract important words/expressions based on the following rules and provide Korean meanings:
                   - If source is Thai (th) -> Extract from INPUT TEXT (Thai words)
                   - If target is Thai (th) -> Extract from TRANSLATED TEXT (Thai words)
                   - If source is English (en) -> Extract from INPUT TEXT (English words)
                   - If target is English (en) -> Extract from TRANSLATED TEXT (English words)
                   - For short texts (under 50 words): extract at least 5-8 words/expressions
                   - For medium texts (50-200 words): extract at least 10-15 words/expressions
                   - For long texts (over 200 words): extract at least 15-20 words/expressions or more
                   - Include all significant nouns, verbs, adjectives, phrases, and idiomatic expressions
                7. Add "pronunciation" field with Korean pronunciation (í•œê¸€ ë°œìŒ) for each Thai word in wordGuide.
                   - If wordGuide contains Thai words (from source or target), ALWAYS include pronunciation field.

                Output JSON ONLY: {
                    "detectedSource": "LANG_CODE",
                    "translatedText": "TEXT",
                    "wordGuide": [
                        {
                            "word": "ì›ë¬¸ë‹¨ì–´",
                            "meaning": "í•œêµ­ì–´ ì˜ë¯¸",
                            "pronunciation": "í•œê¸€ë°œìŒ (ì›ë¬¸ì´ íƒœêµ­ì–´ì¼ ë•Œë§Œ)",
                            "example": "ì˜ˆë¬¸ (ì„ íƒì )"
                        }
                    ]
                }

                Note:
                - wordGuide extraction rules:
                  * Thai -> Korean: Extract Thai words from INPUT TEXT
                  * Korean -> Thai: Extract Thai words from TRANSLATED TEXT
                  * English -> Korean: Extract English words from INPUT TEXT
                  * Korean -> English: Extract English words from TRANSLATED TEXT
                  * Thai -> English: Extract Thai words from INPUT TEXT
                  * English -> Thai: Extract Thai words from TRANSLATED TEXT
                - wordGuide should contain as many important words/expressions as possible (minimum 8-15 items, more for longer texts).
                - Include all significant vocabulary: nouns, verbs, adjectives, phrases, idioms, and key expressions.
                - Prioritize words that are commonly used, culturally significant, or difficult to understand.
                - ALWAYS provide Korean meanings for all extracted words.
                - If wordGuide contains Thai words, ALWAYS include "pronunciation" field with Korean pronunciation (í•œê¸€) for each Thai word.
                `;
        }

        async function translateShortText(text, outputText, spinner, errorLog) {
            try {
                const prompt = buildTranslationPrompt(text, state.sourceLang, state.targetLang, state.tone);
                const result = await callTranslationAPI(prompt, state.apiKey || defaultApiKey);

                if (!result.translatedText || !result.detectedSource) {
                    throw new Error("Invalid translation result format");
                }

                // Ensure wordGuide exists (backward compatibility)
                if (!result.wordGuide) {
                    result.wordGuide = [];
                }

                // Display results
                displayTranslationResult(result, outputText, spinner);

                // Display word guide
                let wordGuideTargetLang = state.targetLang;
                if (wordGuideTargetLang === 'auto') {
                    wordGuideTargetLang = (result.detectedSource === 'ko') ? 'th' : 'ko';
                }
                displayWordGuide(result.wordGuide, result.detectedSource, wordGuideTargetLang);

                // Play TTS
                let ttsLang = state.targetLang;
                if (ttsLang === 'auto') {
                    ttsLang = (result.detectedSource === 'ko') ? 'th' : 'ko';
                }
                state.lastLang = ttsLang;
                playTTS(result.translatedText, ttsLang);

            } catch (error) {
                throw error; // ìƒìœ„ í•¨ìˆ˜ì—ì„œ ì²˜ë¦¬
            }
        }

        async function callTranslationAPI(prompt, apiKey) {
            const apiLLM = `${CONFIG.API_BASE_URL}/${CONFIG.MODEL_NAME}:generateContent?key=${apiKey}`;

            const response = await fetch(apiLLM, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: { responseMimeType: "application/json" }
                })
            });

            if (!response.ok) {
                if (response.status === 401) throw new Error("API Key Invalid (401)");
                throw new Error(`API Request Failed: ${response.status}`);
            }

            const data = await response.json();
            if (!data.candidates || !data.candidates[0] || !data.candidates[0].content || !data.candidates[0].content.parts || !data.candidates[0].content.parts[0]) {
                throw new Error("Invalid API response format");
            }

            const result = JSON.parse(data.candidates[0].content.parts[0].text);
            return result;
        }

        function displayTranslationResult(result, outputText, spinner) {
            spinner.classList.add('hidden');
            outputText.innerText = result.translatedText;
            const detectedLabel = document.getElementById('detected-lang-label');
            if (detectedLabel) detectedLabel.innerText = result.detectedSource.toUpperCase();
            state.lastResult = result.translatedText;
        }

        // BROWSER TTS (Native) - V7 Logic Restored
        function playTTS(text, lang) {
            window.speechSynthesis.cancel();
            const u = new SpeechSynthesisUtterance(text);

            if (lang === 'th') u.lang = 'th-TH';
            else if (lang === 'ko') u.lang = 'ko-KR';
            else if (lang === 'en') u.lang = 'en-US';
            else u.lang = 'th-TH';

            u.rate = 0.9;
            window.speechSynthesis.speak(u);
        }

        function copyResult() {
            navigator.clipboard.writeText(state.lastResult);
            showToast(I18N[state.uiLang].copied);
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toast-message');
            
            if (!toast || !toastMessage) return;
            
            toastMessage.textContent = message;
            toast.classList.remove('hidden');
            
            // 3ì´ˆ í›„ ìë™ìœ¼ë¡œ ìˆ¨ê¹€
            setTimeout(() => {
                toast.classList.add('hidden');
            }, 3000);
        }

        // --- WORD GUIDE FUNCTIONS ---
        function displayWordGuide(wordGuide, detectedSource, targetLang) {
            const wordGuideSection = document.getElementById('word-guide-section');
            const wordGuideContent = document.getElementById('word-guide-content');

            if (!wordGuideSection || !wordGuideContent) return;

            // Hide if no word guide
            if (!wordGuide || !Array.isArray(wordGuide) || wordGuide.length === 0) {
                wordGuideSection.classList.add('hidden');
                return;
            }

            // Show section
            wordGuideSection.classList.remove('hidden');
            wordGuideContent.classList.add('hidden'); // Start collapsed

            // Clear previous content
            wordGuideContent.innerHTML = '';

            // Determine if we should show pronunciation (for Thai words)
            // íƒœêµ­ì–´ ë‹¨ì–´ê°€ í¬í•¨ë˜ì–´ ìˆìœ¼ë©´ ë°œìŒ í‘œì‹œ (ì›ë¬¸ ë˜ëŠ” ë²ˆì—­ ê²°ê³¼)
            const hasThaiWords = detectedSource === 'th' || targetLang === 'th';

            // Create word guide items
            wordGuide.forEach((item, index) => {
                const wordItem = document.createElement('div');
                wordItem.className = 'p-3 bg-gray-800/50 rounded-lg border border-gray-700';

                // íƒœêµ­ì–´ ë‹¨ì–´ì™€ ë°œìŒì„ í•¨ê»˜ í‘œì‹œ: "íƒœêµ­ì–´ ë‹¨ì–´ (í•œêµ­ì–´ ë°œìŒ)"
                const wordDisplay = hasThaiWords && item.pronunciation
                    ? `${item.word || ''} <span class="text-blue-300 font-medium">(${item.pronunciation})</span>`
                    : item.word || '';

                wordItem.innerHTML = `
                    <div class="flex items-start gap-3">
                        <span class="text-blue-400 font-bold text-xs min-w-[24px]">${index + 1}.</span>
                        <div class="flex-1">
                            <div class="flex items-center gap-2 mb-1">
                                <span class="font-bold text-white text-sm">${wordDisplay}</span>
                            </div>
                            <div class="text-gray-300 text-xs mb-1">
                                <span class="text-gray-500">${I18N[state.uiLang].meaning}:</span> ${item.meaning || ''}
                            </div>
                            ${item.example ? `
                                <div class="text-gray-400 text-xs italic mt-1">
                                    <span class="text-gray-500">${I18N[state.uiLang].example}:</span> ${item.example}
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
                wordGuideContent.appendChild(wordItem);
            });

            // Update i18n text
            const toggleText = document.getElementById('word-guide-toggle-text');
            if (toggleText && I18N[state.uiLang].wordGuide) {
                toggleText.innerText = I18N[state.uiLang].wordGuide;
            }
        }

        function toggleWordGuide() {
            const wordGuideContent = document.getElementById('word-guide-content');
            const wordGuideIcon = document.getElementById('word-guide-icon');

            if (!wordGuideContent || !wordGuideIcon) return;

            const isHidden = wordGuideContent.classList.contains('hidden');

            if (isHidden) {
                wordGuideContent.classList.remove('hidden');
                wordGuideIcon.classList.remove('fa-chevron-down');
                wordGuideIcon.classList.add('fa-chevron-up');
            } else {
                wordGuideContent.classList.add('hidden');
                wordGuideIcon.classList.remove('fa-chevron-up');
                wordGuideIcon.classList.add('fa-chevron-down');
            }
        }

        // --- VOICE INPUT FUNCTIONS ---
        function initSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                console.warn('Speech recognition not supported');
                return null;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();

            // ì„¤ì •
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = getRecognitionLanguage();

            // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
            recognition.onstart = () => {
                isListening = true;
                const voiceStatus = document.getElementById('voice-status');
                if (voiceStatus) voiceStatus.classList.remove('hidden');
                updateVoiceButton(true);
            };

            recognition.onresult = (event) => {
                let finalTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript + ' ';
                    }
                }

                if (finalTranscript) {
                    const inputText = document.getElementById('input-text');
                    const currentText = inputText.value;
                    inputText.value = (currentText + finalTranscript).trim();
                }
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                stopVoiceInput();
                if (event.error === 'no-speech') {
                    // ìŒì„±ì´ ì—†ì„ ë•ŒëŠ” ì¡°ìš©íˆ ì¢…ë£Œ
                    return;
                }
                alert('ìŒì„± ì¸ì‹ ì˜¤ë¥˜: ' + event.error);
            };

            recognition.onend = () => {
                isListening = false;
                const voiceStatus = document.getElementById('voice-status');
                if (voiceStatus) voiceStatus.classList.add('hidden');
                updateVoiceButton(false);
            };

            return recognition;
        }

        function startVoiceInput() {
            if (!recognition) {
                recognition = initSpeechRecognition();
                if (!recognition) {
                    alert('ì´ ë¸Œë¼ìš°ì €ëŠ” ìŒì„± ì¸ì‹ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\nChrome ë˜ëŠ” Edge ë¸Œë¼ìš°ì €ë¥¼ ì‚¬ìš©í•´ì£¼ì„¸ìš”.');
                    return;
                }
            }

            if (isListening) {
                stopVoiceInput();
            } else {
                recognition.lang = getRecognitionLanguage();
                try {
                    recognition.start();
                } catch (error) {
                    console.error('Failed to start recognition:', error);
                    alert('ìŒì„± ì¸ì‹ì„ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                }
            }
        }

        function stopVoiceInput() {
            if (recognition && isListening) {
                recognition.stop();
            }
        }

        function getRecognitionLanguage() {
            const langMap = {
                'ko': 'ko-KR',
                'th': 'th-TH',
                'en': 'en-US',
                'auto': 'ko-KR'
            };

            return langMap[state.sourceLang] || 'ko-KR';
        }

        function updateVoiceButton(listening) {
            const btn = document.getElementById('voice-input-btn');
            if (btn) {
                if (listening) {
                    btn.classList.remove('text-gray-600', 'hover:text-blue-400');
                    btn.classList.add('text-red-500', 'animate-pulse');
                } else {
                    btn.classList.remove('text-red-500', 'animate-pulse');
                    btn.classList.add('text-gray-600', 'hover:text-blue-400');
                }
            }
        }

        // --- OCR FUNCTIONS ---
        async function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            // íŒŒì¼ í¬ê¸° ì œí•œ (10MB)
            if (file.size > 10 * 1024 * 1024) {
                alert('ì´ë¯¸ì§€ í¬ê¸°ëŠ” 10MB ì´í•˜ì—¬ì•¼ í•©ë‹ˆë‹¤.');
                return;
            }

            const reader = new FileReader();
            reader.onload = async (e) => {
                const imageUrl = e.target.result;
                await performOCR(imageUrl);
            };

            reader.readAsDataURL(file);
        }

        async function performOCR(imageUrl) {
            const ocrProgress = document.getElementById('ocr-progress');
            const ocrProgressBar = document.getElementById('ocr-progress-bar');
            const ocrProgressText = document.getElementById('ocr-progress-text');

            if (!ocrProgress || !ocrProgressBar || !ocrProgressText) return;

            ocrProgress.classList.remove('hidden');
            ocrProgressBar.style.width = '0%';
            ocrProgressText.textContent = '0%';

            try {
                const { data: { text } } = await Tesseract.recognize(
                    imageUrl,
                    getOCRLanguage(),
                    {
                        logger: m => {
                            if (m.status === 'recognizing text') {
                                const progress = Math.round(m.progress * 100);
                                ocrProgressBar.style.width = progress + '%';
                                ocrProgressText.textContent = progress + '%';
                            }
                        }
                    }
                );

                // ì¶”ì¶œëœ í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥ì°½ì— ì¶”ê°€
                const inputText = document.getElementById('input-text');
                const currentText = inputText.value.trim();
                const extractedText = text.trim();

                if (extractedText) {
                    inputText.value = currentText ? (currentText + '\n\n' + extractedText) : extractedText;
                } else {
                    alert('ì´ë¯¸ì§€ì—ì„œ í…ìŠ¤íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                }

            } catch (error) {
                console.error('OCR Error:', error);
                alert('ì´ë¯¸ì§€ì—ì„œ í…ìŠ¤íŠ¸ë¥¼ ì¶”ì¶œí•˜ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + error.message);
            } finally {
                ocrProgress.classList.add('hidden');
                // íŒŒì¼ ì…ë ¥ ì´ˆê¸°í™”
                document.getElementById('image-input').value = '';
            }
        }

        function getOCRLanguage() {
            const langMap = {
                'ko': 'kor',
                'th': 'tha',
                'en': 'eng',
                'auto': 'kor+eng+tha'
            };

            return langMap[state.sourceLang] || 'kor+eng+tha';
        }


    </script>
</body>

</html>
